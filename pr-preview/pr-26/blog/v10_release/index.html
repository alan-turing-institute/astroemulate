<!DOCTYPE html><head><!-- Thumbnail when sharing site --><meta property="og:title" content="Accelerating large-scale simulations with AI"><meta property="og:description" content="Python library for automatically creating accurate and efficient emulators of complex simulations."><meta property="og:image" content="https://raw.githubusercontent.com/alan-turing-institute/astroemulate/refs/heads/main/src/assets/autoemulate_logo_wide.png"><meta property="og:url" content="https://www.autoemulate.com"><meta property="og:type" content="website"><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/png" href="https://raw.githubusercontent.com/alan-turing-institute/astroemulate/refs/heads/main/src/assets/autoemulate_logo_no_grid.png"><meta name="generator" content="Astro v5.4.2"><title>AutoEmulate v1.0.0 release</title><link rel="stylesheet" href="/_astro/team.CWfRlc7G.css"><script>!(function(w,p,f,c){if(!window.crossOriginIsolated && !navigator.serviceWorker) return;c=w[p]=Object.assign(w[p]||{},{"lib":"/~partytown/","debug":false});c[f]=(c[f]||[]).concat(["dataLayer.push"])})(window,'partytown','forward');/* Partytown 0.11.0 - MIT QwikDev */
const t={preserveBehavior:!1},e=e=>{if("string"==typeof e)return[e,t];const[n,r=t]=e;return[n,{...t,...r}]},n=Object.freeze((t=>{const e=new Set;let n=[];do{Object.getOwnPropertyNames(n).forEach((t=>{"function"==typeof n[t]&&e.add(t)}))}while((n=Object.getPrototypeOf(n))!==Object.prototype);return Array.from(e)})());!function(t,r,o,i,a,s,c,l,d,p,u=t,f){function h(){f||(f=1,"/"==(c=(s.lib||"/~partytown/")+(s.debug?"debug/":""))[0]&&(d=r.querySelectorAll('script[type="text/partytown"]'),i!=t?i.dispatchEvent(new CustomEvent("pt1",{detail:t})):(l=setTimeout(v,(null==s?void 0:s.fallbackTimeout)||1e4),r.addEventListener("pt0",w),a?y(1):o.serviceWorker?o.serviceWorker.register(c+(s.swPath||"partytown-sw.js"),{scope:c}).then((function(t){t.active?y():t.installing&&t.installing.addEventListener("statechange",(function(t){"activated"==t.target.state&&y()}))}),console.error):v())))}function y(e){p=r.createElement(e?"script":"iframe"),t._pttab=Date.now(),e||(p.style.display="block",p.style.width="0",p.style.height="0",p.style.border="0",p.style.visibility="hidden",p.setAttribute("aria-hidden",!0)),p.src=c+"partytown-"+(e?"atomics.js?v=0.11.0":"sandbox-sw.html?"+t._pttab),r.querySelector(s.sandboxParent||"body").appendChild(p)}function v(n,o){for(w(),i==t&&(s.forward||[]).map((function(n){const[r]=e(n);delete t[r.split(".")[0]]})),n=0;n<d.length;n++)(o=r.createElement("script")).innerHTML=d[n].innerHTML,o.nonce=s.nonce,r.head.appendChild(o);p&&p.parentNode.removeChild(p)}function w(){clearTimeout(l)}s=t.partytown||{},i==t&&(s.forward||[]).map((function(r){const[o,{preserveBehavior:i}]=e(r);u=t,o.split(".").map((function(e,r,o){var a;u=u[o[r]]=r+1<o.length?u[o[r]]||(a=o[r+1],n.includes(a)?[]:{}):(()=>{let e=null;if(i){const{methodOrProperty:n,thisObject:r}=((t,e)=>{let n=t;for(let t=0;t<e.length-1;t+=1)n=n[e[t]];return{thisObject:n,methodOrProperty:e.length>0?n[e[e.length-1]]:void 0}})(t,o);"function"==typeof n&&(e=(...t)=>n.apply(r,...t))}return function(){let n;return e&&(n=e(arguments)),(t._ptf=t._ptf||[]).push(o,arguments),n}})()}))})),"complete"==r.readyState?h():(t.addEventListener("DOMContentLoaded",h),t.addEventListener("load",h))}(window,document,navigator,top,window.crossOriginIsolated);;(e=>{e.addEventListener("astro:before-swap",e=>{let r=document.body.querySelector("iframe[src*='/~partytown/']");if(r)e.newDocument.body.append(r)})})(document);</script></head> <div id="container"> <img id="background" src="/_astro/background.BPKAcmfN.svg" alt="" fetchpriority="high"> <main> <nav class="navbar" id="navbar" data-astro-cid-5blmo7yk> <a class="homelink desktop-only" href="/" style="color: inherit; text-decoration: none;" data-astro-cid-5blmo7yk> <img src="/_astro/autoemulate_logo_no_grid.C5MLkt-6.png" width="100" alt="AutoEmulate Logo" data-astro-cid-5blmo7yk> <sub class="navbar-logo-text" data-astro-cid-5blmo7yk><b data-astro-cid-5blmo7yk>utoEmulate</b></sub> </a> <button class="hamburger" id="hamburger" aria-label="Toggle navigation" data-astro-cid-5blmo7yk>
&#9776;
</button> <div class="navbar-right" id="navbar-right" data-astro-cid-5blmo7yk> <a class="mobile-only" href="/" data-astro-cid-5blmo7yk>Home</a> <a href="/team" data-astro-cid-5blmo7yk>Team</a> <a href="/blog" data-astro-cid-5blmo7yk>Blog</a> <div class="dropdown" data-astro-cid-5blmo7yk> <button class="dropbtn" id="resources-btn" data-astro-cid-5blmo7yk>
Info
<span class="arrow" id="resources-arrow" data-astro-cid-5blmo7yk>&#9654;</span> </button> <div class="dropdown-content" id="resources-dropdown" data-astro-cid-5blmo7yk> <a href="https://alan-turing-institute.github.io/autoemulate/index.html" target="_blank" data-astro-cid-5blmo7yk>Documentation</a> <a href="https://joss.theoj.org/papers/10.21105/joss.07626" target="_blank" data-astro-cid-5blmo7yk>JOSS Paper</a> <a href="https://github.com/alan-turing-institute/autoemulate" target="_blank" data-astro-cid-5blmo7yk>GitHub</a> <a href="https://pypi.org/project/autoemulate" target="_blank" data-astro-cid-5blmo7yk>PyPI</a> <a href="https://alan-turing-institute.github.io/gp-demo/" target="_blank" data-astro-cid-5blmo7yk>What is emulation?</a> </div> </div> </div> </nav>  <script type="module">const d=document.getElementById("hamburger"),o=document.getElementById("navbar-right");d.addEventListener("click",()=>{o.classList.toggle("active")});window.addEventListener("scroll",function(){const t=document.getElementById("navbar");window.scrollY>window.innerHeight/2?t.classList.add("hidden"):t.classList.remove("hidden")});const n=document.getElementById("resources-btn"),e=n.parentElement;n.addEventListener("mouseenter",()=>{e.classList.add("open")});n.addEventListener("mouseleave",()=>{e.classList.remove("open")});const s=document.getElementById("resources-dropdown");s.addEventListener("mouseenter",()=>{e.classList.add("open")});s.addEventListener("mouseleave",()=>{e.classList.remove("open")});</script> <div class="blog"> <article class="blog-article"> <header class="blog-header"> <h1>AutoEmulate v1.0.0 release</h1> <p class="blog-meta"> <strong>AutoEmulate contributors</strong> - 7/31/2025 </p><br><br> <p class="blog-description">Updates on new features in v1.0.0 release</p>  <br> <br> <p class="blog-release"> <strong>Release:</strong> <a href="https://github.com/alan-turing-institute/autoemulate/releases/tag/v1.0.0"> v1.0.0 </a> </p>  </header> <section class="blog-content">  <div><ul>
<li><a href="#whats-new">What&#39;s new</a><ul>
<li><a href="#pytorch-refactor-and-package-redesign">PyTorch refactor and package redesign</a></li>
<li><a href="#a-new-set-of-emulator-models">A new set of Emulator models</a></li>
<li><a href="#bayesian-model-calibration">Bayesian model calibration</a></li>
<li><a href="#upgraded-features">Upgraded features</a></li>
<li><a href="#key-api-changes">Key API changes</a></li>
</ul>
</li>
<li><a href="#whats-next">What&#39;s next</a></li>
</ul>
<p>üéâ We&#39;re excited to announce AutoEmulate&#39;s first major release with v1.0.0 üéâ</p>
<p><br/><br/>
This release sees the package fully integrated into the PyTorch ecosystem; PyTorch is one of the most popular open-source deep learning frameworks and one of the bedrocks of modern machine learning with Python.</p>
<p>This release also contains new features, including methods for uncertainty quantification;  ensemble-based emulator models, which output predictions with uncertainty, and Bayesian model calibration, which enables inference of parameters likely to have generated observed data with uncertainty.</p>
<p><br/><br/>
If you&#39;d like to discuss any of our work on AutoEmulate or AI for Physical Systems, feel free to reach out to us at <a href="mailto:ai4physics@turing.ac.uk">ai4physics@turing.ac.uk</a></p>
<h2 id="whats-new">What&#39;s new</h2>
<h3 id="pytorch-refactor-and-package-redesign">PyTorch refactor and package redesign</h3>
<p>AutoEmulate was originally built on top of the scikit-learn framework, which is a great library for traditional machine learning tasks. However, as we moved towards more complex models and larger datasets, we found that we needed the flexibility and performance that PyTorch provides.</p>
<p><br/><br/>
The new PyTorch backend allows AutoEmulate to take advantage of PyTorch&#39;s powerful features, including (but not limited to):</p>
<ul>
<li>Leveraging GPU acceleration, making training and inference much faster.</li>
<li>Enabling automatic differentiation via PyTorch&#39;s autograd system.</li>
<li>Seamlessly integrating AutoEmulate with other tools in the broader ecosystem, enabling end-to-end emulation workflows.</li>
</ul>
<h3 id="a-new-set-of-emulator-models">A new set of Emulator models</h3>
<p>AutoEmulate v1.0.0 includes a new set of Emulator models with a variety of different architectures, built on top of PyTorch (and GPyTorch for Gaussian processes). Many of these are custom implementations built by the AutoEmulate team, including ensemble models where we quantify uncertainty by looking at the distribution over outputs, but some are simply wrapped PyTorch functions.
<br/>
Additionally, we have retained support for several non-PyTorch models that our userbase has found useful. The table below summarises which emulators available in this release are implemented in PyTorch, support multi-output emulation (MO), use auto-differentiation (AD) for training, or provide predictive uncertainty quantification (UQ).</p>
<table>
<thead>
<tr>
<th>Emulator</th>
<th>PyTorch</th>
<th>MO</th>
<th>AD</th>
<th>UQ</th>
</tr>
</thead>
<tbody><tr>
<td>GaussianProcess</td>
<td>‚úîÔ∏è</td>
<td>‚úîÔ∏è</td>
<td>‚úîÔ∏è</td>
<td>‚úîÔ∏è</td>
</tr>
<tr>
<td>GaussianProcessCorrelated</td>
<td>‚úîÔ∏è</td>
<td>‚úîÔ∏è</td>
<td>‚úîÔ∏è</td>
<td>‚úîÔ∏è</td>
</tr>
<tr>
<td>EnsembleMLP</td>
<td>‚úîÔ∏è</td>
<td>‚úîÔ∏è</td>
<td>‚úîÔ∏è</td>
<td>‚úîÔ∏è</td>
</tr>
<tr>
<td>EnsembleMLPDropout</td>
<td>‚úîÔ∏è</td>
<td>‚úîÔ∏è</td>
<td>‚úîÔ∏è</td>
<td>‚úîÔ∏è</td>
</tr>
<tr>
<td>MLP</td>
<td>‚úîÔ∏è</td>
<td>‚úîÔ∏è</td>
<td>‚úîÔ∏è</td>
<td>‚ùå</td>
</tr>
<tr>
<td>PolynomialRegression</td>
<td>‚úîÔ∏è</td>
<td>‚úîÔ∏è</td>
<td>‚úîÔ∏è</td>
<td>‚ùå</td>
</tr>
<tr>
<td>RadialBasisFunctions</td>
<td>‚úîÔ∏è</td>
<td>‚úîÔ∏è</td>
<td>‚ùå</td>
<td>‚ùå</td>
</tr>
<tr>
<td>RandomForest</td>
<td>scikit-learn</td>
<td>‚úîÔ∏è</td>
<td>‚ùå</td>
<td>‚ùå</td>
</tr>
<tr>
<td>SupportVectorMachine</td>
<td>scikit-learn</td>
<td>‚ùå</td>
<td>‚ùå</td>
<td>‚ùå</td>
</tr>
<tr>
<td>LightGBM</td>
<td>LightGBM</td>
<td>‚ùå</td>
<td>‚ùå</td>
<td>‚ùå</td>
</tr>
</tbody></table>
<h3 id="bayesian-model-calibration">Bayesian model calibration</h3>
<p>Bayesian calibration is a method for estimating which input parameters were most likely to produce observed data. An advantage over other calibration methods is that it returns a probability distribution over the input parameters rather than just point estimates.
Performing Bayesian calibration requires a fit emulator and observations associated with the simulator output. Check out our new <a href="URL">tutorial</a> for more details on how to use this feature.</p>
<h3 id="upgraded-features">Upgraded features</h3>
<ul>
<li><strong>Simulator in the loop</strong>: Some features in AutoEmulate such as <em>active learning</em> require the user to provide a simulator that can be run by AutoEmulate. AutoEmulate now supports easy integration of simulators into the emulation workflow. This is achieved through a subclassing mechanism of the <em>Simulator</em> base class, allowing the users to define a method to run their simulation, taking in the input parameters and returning the output variables. See our <a href="URL">custom simulations tutorial</a> for more details.</li>
<li><strong>Active learning</strong> is now a core feature of AutoEmulate. Active learning intelligently selects informative simulator evaluations to maximize emulator improvement with minimal computational cost. See our <a href="URL">active learning tutorial</a> for more details.</li>
<li><strong>History matching</strong> <em>TODO: explain changes</em>. See our two updated history matching tutorials <a href="URL">1</a> and <a href="URL">2</a> for more details.</li>
</ul>
<h3 id="key-api-changes">Key API changes</h3>
<p>As with previous releases, AutoEmulate v1.0.0 can be used to quickly get an emulator from simulation inputs (x) and outputs (y). This now happens in a single step:</p>
<pre><code class="language-python">ae = AutoEmulate(x, y)
</code></pre>
<p>This replaces the previous two-step process of <code>ae.setup(x, y)</code> and <code>ae.compare()</code>. Check out the <a href="URL">Quick Start Guide</a> for more details on how to use the new API.</p>
<h2 id="whats-next">What&#39;s next</h2>
<p>Looking ahead, we are working on providing support for more complex simulation outputs including spatial and temporal data, which will allow a wider range of applications to benefit from AutoEmulate.</p>
</div>  </section> </article> </div> </main> <script type="module">window.addEventListener("scroll",function(){const n=document.getElementById("navbar");window.scrollY>window.innerHeight/2?n.classList.add("hidden"):n.classList.remove("hidden")});</script> </div>